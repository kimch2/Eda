
C#のプロパティは演算子のオーバーライドだよ
プロパティでGETを書いた場合は読み取れるようになるから=の右辺に書いたり
四則演算で使用できるようになる
プロパティのSETを書けば　書き込みができるようになるから＝の左辺に書ける

今日一日中サイト回ってたが使い方が理解できない
 get { return x; }
 set { x = value; }

これどう使うんだよマジで

getterメソッド、setterメソッドってわかるかな？
それを言語使用として用意したものがC#のプロパティです

ゲッターのみで読み取り専用
セッターのみで書き込み専用
両方書けば読み書き可能

その二つを定義するとフィールド変数X　という変数は
getterメソッドとsetterメソッドを作ったのと同じことになるのよ

a = getX()  の代わりに　a = X
setX(1)  の代わりに　X =　1

と書けるようになる

例えば、時給計算クラスというクラスが合って
int 時間;
int 給料;

to
[0:36:57] セリカ 青緑波紋疾走: int 時間;
int 給料;

public int get給料()
public void set給料(int)
public int get時間()
public void set時間(int)

っていう4つのメソッドがあったとして時給を計算しようと思ったら

get時間()　* get給料（）

になるし、働いた時間と、時給を設定したかったら

set時間(8）
set給料(1000)

って書かないといけないでしょ

でも、プロパティがフィールド変数の時間と給料に設定されていれば
時間　*　給料

とか

時間　=　8
給料　=　1000

とか書けるようになる
フィールド変数の時間と給料は

private int 時間
private int 給料

ってのが大事だね

C#やJavaなどのオブジェクト指向言語ではメンバ変数のことを　フィールド　という
関数のことを　メソッド　という

メンバ変数ってローカル変数の事だっけ？
構造体に参加している変数とかのことだね

構造体を作るとき、その構造体にどのような型の変数がいくつ、なんという名前で存在するかを　struct構文を使って定義するでしょ
public int 時間
private int 時間

これどちらもフィールド
ただし、アクセス修飾子がprivateであるフィールドは
外部から参照ができないのよ

クラスのフィールド変数を定義します
そのクラス内でフィールド変数に自由にアクセスできます

class test {
    private int aaaa;　　　←プライベートフィールドを宣言

    public void display() {
        System.out.print.ln(aaaa);    ←同一クラス内では自由に使用可能
    }
}
class test2 {
    Test testObj = new Test();
    testObj.aaaa = 1000;   ←外部からのアクセスは不可能
}

で、アクセス修飾子がprivateであるフィールド変数には外部からアクセスすることができないから
どうやってその変数に値を設定しようか？
と考えたときに使用されるのがgetterメソッドとsetter()メソッドなのよ

class test {
    private int 変数1;

    public void set変数1(int arg) {
        変数1　= arg;
    }

    public int get変数1() {
        return 変数1
    }
}

こういう風に　setterメソッドとgetterメソッド　を定義しておくことで
privateであり外部から参照できないフィールドに対して
メソッドを経由して値を設定したり取得したりできるようになる

[0:51:02] セリカ 青緑波紋疾走: ここまではOK？
[0:52:45] ＠mugen しぃ（41）: 今まで全く認識してなかったんだが、
＞どうやってその変数に値を設定しようか？
＞と考えたときに使用されるのが
＞getterメソッドとsetter()メソッドなのよ

え？そうなの？
ていうか、そもそも、外部のどこからでもアクセスされると困るフィールドだから
private修飾子を付けるんじゃないの？

正確に言うと、
×外部からアクセスされると困るフィールドだから
○プログラマが想定していない値を設定されると困るフィールドだから

変数っていうのはプログラムでは入力になるわけだから何らかの処理をしたかったら必要になるものじゃない
でも、publicなフィールドを作ってそこに直接代入させた場合、例えば
clas 生き物　{
    public int age;　　←生き物の年齢
    public int sex;　　←生き物の性別(1:男, 2:女, 3:その他）
}

みたいなクラスが合ったとして
生き物　　生き物インスタンス = new 生き物();
生き物インスタンス.age = -1000;
生き物インスタンス.sex = 1000;

なんて代入されたらこの入力はプログラマとしては嬉しくないのさ
生き物の年齢が　マイナスであることはありえないし
性別としては　1か2か3　を使うと決めていたとすると1000　もありがたくないでしょ

ここでgetterメソッドとsetterメソッドの出番なのよ

フィールド自体はprivateにして外部から直接入力できないようにする
ただし、フィールドにはsetterメソッドとgetterメソッドを用意する
そうすると、このメソッド内で嬉しくない入力をはじくことができるのさ
class 生き物　{
    private int age;
    private int sex;

    publid void setAge(int arg) {
        if(age <0 ) {
            throw Exception(”年齢は0以上必須");
       }
       age = arg;
    }

    public void setSex(int arg) {
       if(set < 1 && sex > 3) {
          throw Exception("性別は1:男, 2:女, 3:その他のいずれかのみ”);
        }
    }
}

こうすると、フィールドであるageとsexにはプログラマとして想定していない値は絶対に入らない
という前提を作ることができる
こういう考え方を「カプセル化」と言います
つまり、生き物クラス内でageやsexを使用する場合想定外の値が入っていることをチェックしなくてよいのよ

プログラミングは例外処理が非常に多いじゃない
この変数にはこの範囲の値じゃないといけないとか
で、商業で作られるプログラミングのうち60〜70%はこれら例外処理に費やされている

これを、settertメソッド、getterメソッドを使用して入出力の時点で異常入力をはじいておけば
class内部でそれを使うときには異常な値が入ってくることは考慮しなくていいから　この60〜70％が削れるよね！！
っていう考え方

privateなフィールドとそれに対するpublicなメソッドインタフェースを
使用することで、今から使おうとしているこの変数には
もしかしたら想定外の値が入っているのではないだろうか？
という疑いを晴らそうとするわけです

このsetterメソッドとgetterメソッドを言語使用的にもっと直観的かつ
記述量を少ないしたいよねということで作られた仕組みがC#のプロパティです

setAge()と、setSex()というメソッドがsetterだよ
フィールドのageとsexはプライベート宣言だから直接参照できない
そのため、そのフィールドに値を設定するメソッドとして
setAge()とsetSex（）がある

大事なことは、クラスって何らかの入力を貰って何らかの処理を行って何らかの出力を出す
というプログラムの一部品だから、入力はそのクラスを使う外部からもたらされるもの
なわけですよ

publid void setAge(int arg) {
    if(age <0 ) {
        throw Exception(”年齢は0以上必須");
   }
   age = arg;  ←ここでフィールドに設定してるっしょ
}

privateなフィールドに対して外部からの入力を行うメソッドをsetter
外部への出力を行うメソッドをgetterというのです

publicなフィールドに直接代入させるのではなくメソッドを経由することで、してほしくない入力をさせない

getterとsetterって安全にprivateフィールドを読み書きしようね、っていうものなの？
そうだよ

ていうか、プロパティってそういうものなの？
そうだよ　そして、そうすることでオブジェクトをカプセル化しようねってこと
こうすることで、結合を疎結合にして使いまわせるようにしたいね
っていうこと
枝は今RPG作っているんでしょ？
キャラクタークラスってのがあったとしたら
そのキャラクタークラスにHPやレベルを持たせているかもしれないでしょ
そのHPやレベルを持たせている変数を直接参照して
プログラム上で書き換えると
間違えて　最大HPや最大レベルを超えた値を入れちゃうかもしれないでしょ
うん
それをメソッド経由にすることで防ぎましょう　ってことです
異常値をフェールセーフに倒せるのであれば　それが良い
でも、フェールセーフがないのなら例外を投げちゃう　とか
入力の異常値をどのように扱うか　ってのは仕様によるけどね

すまん、一つだけプロパティからズレる事聞くけどinterfaceの中の要素って全部publicだよな？
intafeceの宣言は自動的にabstract publicだわ

[1:22:09] ＠mugen しぃ（41）: http://msdn.microsoft.com/ja-jp/library/ms228387(v=vs.90).aspx

ここの

public int X
    {
        get { return x; }
        set { x = value; }
    }

ここが分からん
一体何してるんだこれ？？
[1:22:21] ＠mugen しぃ（41）: [1:22] ＠mugen しぃ（41）: 

<<<    get { return x; }
        set { x = value; }
[1:22:27] ＠mugen しぃ（41）: ↑当然これがプロパティだよな？
[1:22:34] セリカ 青緑波紋疾走: そこがプロパティだね
[1:22:51] ＠mugen しぃ（41）: [1:22] ＠mugen しぃ（41）: 

<<< get { return x; }が分からん
こんな記述見たことない
[1:23:30] セリカ 青緑波紋疾走: 外部に公開するメソッド名として
public int 「X」　　←このXがメソッド名になる

Xを定義している
[1:23:37] ＠mugen しぃ（41）: getterは読み取り専用だからXを読み込んでいるの？
[1:23:51] セリカ 青緑波紋疾走: そのXの入力動作として　set {}
そのXの出力動作として　get {}
[1:24:50] ＠mugen しぃ（41）: ＞外部に公開するメソッド名として
＞public int 「X」　　←このXがメソッド名になる

＞Xを定義している

↑とりあえずこれは理解した
[1:25:22] セリカ 青緑波紋疾走: private int test; ←プライベートフィールドを定義
public int Test {
    set{ this.test = value; }
    get{ return this.test; }
} 

こうすることで　プライベートフィールドtest に対して
Testという名称でアクセスができるようになる
[1:26:10] セリカ 青緑波紋疾走: Test　=　1　
とか
a = Test 
とか書ける
[1:26:30] ＠mugen しぃ（41）: ちょっと分かったかも
[1:26:44] セリカ 青緑波紋疾走: setTest()　とか　getTest() とか書かなくていい
[1:27:02] ＠mugen しぃ（41）: [1:26] セリカ 青緑波紋疾走: 

<<< Test　=　1　これはsetが呼ばれるんだよな？
[1:27:19] ＠mugen しぃ（41）: あれ？逆か？
[1:28:05] セリカ 青緑波紋疾走: [1:25] セリカ&青緑波紋疾走: 

<<<  set{ this.test = value; }この一行は　Test　という名前が　=　の左辺で呼ばれて　代入が発生した場合
つまり
Test = 1　のときとかに呼ばれて

代入される値（この例では1）　が「value」として表現されている
[1:28:37] ＠mugen しぃ（41）: なるほど、了解
[1:28:47] セリカ 青緑波紋疾走: Test = add(1, 3) なんかの場合も
set{} が呼ばれる
[1:28:58] ＠mugen しぃ（41）: はい
[1:29:11] セリカ 青緑波紋疾走: 逆に
int aaa = add(Test, 3) の場合は
get{}が呼ばれる
[1:29:30] ＠mugen しぃ（41）: なるほど
[1:29:55] ＠mugen しぃ（41）: プロパティからコール元に「返す」からreturnなのか
[1:30:02] セリカ 青緑波紋疾走: そういうことです
[1:30:06] ＠mugen しぃ（41）: おお
[1:30:09] ＠mugen しぃ（41）: 分かった鴨
[1:30:46] セリカ 青緑波紋疾走: 基本的には　set{} が大事
でも、get{} もちゃんと作っておくことで
[1:31:11] セリカ 青緑波紋疾走: クラス内部の処理にバグを作りこんでしまっていた場合でも
そのクラスの出力として想定していない値を
返してしまうことも防げる
[1:31:20] セリカ 青緑波紋疾走: この考え方は　ライブラリを公開するときなんかに凄い重要
[1:31:25] セリカ 青緑波紋疾走: 自分が使っている分には良いんだけど
[1:31:39] セリカ 青緑波紋疾走: 他人に使ってもらった時
マニュアルにない結果が返ってきたら　マジ　激おこ　でしょ
[1:31:47] ＠mugen しぃ（41）: そうだな
[1:32:02] セリカ 青緑波紋疾走: 理解してもらえたようで
[1:32:33] ＠mugen しぃ（41）: 想定外の数値とかが来た場合処理する事を君らプログラマは例外処理って呼ぶの？
[1:33:18] セリカ 青緑波紋疾走: 想定の値が来ても大丈夫なように　if文とかで入出力をチェックして
例外的な値が来た時にも大丈夫なように書くことを

ひっくるめて例外処理と言ったりするね
[1:33:30] セリカ 青緑波紋疾走: もちろんExceptionをcatchした時の処理も例外処理だけど
[1:33:42] ＠mugen しぃ（41）: なるほど
[1:33:45] セリカ 青緑波紋疾走: ×想定の値
○想定外の値
[1:34:31] ＠mugen しぃ（41）: とりあえず、あと2ヶ月以内にinterface、クラス継承、プロパティの3つを実際に使えるようになりたい
[1:34:38] ＠mugen しぃ（41）: よろしく
[1:34:55] セリカ 青緑波紋疾走: クラスの入出力をsetter、getter経由にして
そこで入力と出力で最低限のガードをかけておけば

使う人が変なもの入れても大丈夫だし

自分のバグで変なものを返すことを防げる
[1:35:05] セリカ 青緑波紋疾走: こうすることで、オブジェクトを守る　これがカプセル化　という考え方
[1:35:16] ＠mugen しぃ（41）: とりあえず、明日というか今日は今覚えたプロパティで色々やってみるか
[1:35:22] セリカ 青緑波紋疾走: ほい
[1:35:38] ＠mugen しぃ（41）: 突き合わせて申し訳ない
[1:35:52] セリカ 青緑波紋疾走: 敬称は難しいから注意してね
[1:36:09] セリカ 青緑波紋疾走: 特に、インタフェースがしっかり設計されている場合は
継承ではなく包括が正解であることが多い
[1:36:46] ＠mugen しぃ（41）: C#って多重継承サポート外したらしいな
コード追いにくかったとかで
[1:36:56] セリカ 青緑波紋疾走: うむ
[1:37:13] セリカ 青緑波紋疾走: 今のところ、JavaにしろC#にしろ　多重継承はNGにしているのが多い
[1:37:19] セリカ 青緑波紋疾走: シグネチャの解決が複雑になりすぎるのさ
[1:37:36] ＠mugen しぃ（41）: C++はあったの？
[1:37:41] セリカ 青緑波紋疾走: C++はあった
[1:38:01] セリカ 青緑波紋疾走: 多重継承すると、同一メソッド名、同一引数というシグネチャの一致がどうしても発生するのさ
[1:38:28] セリカ 青緑波紋疾走: そうすると、多重継承により作られたメソッドでは継承元のどちらのメソッドを呼べばいいのかわからなくなる
[1:38:45] セリカ 青緑波紋疾走: これを、プログラマの責務で静的に記してあげる必要があるんだけどさ
[1:39:15] セリカ 青緑波紋疾走: AとBが多重継承されていて　作った人はAの方が重要だと思って
同一シグネチャのメソッドはAの方を呼び出すようにしてたとするでしょ
[1:40:13] セリカ 青緑波紋疾走: でも、使う人は　B　の機能を継承されているから使いたいと判断した場合
Aにも同一シグネチャのメソッドが実は実装されていて
さらに、このAとBを多重継承したクラスではAのメソッドを呼ぶようにしているなんて言うのは
クラスの中身を見ないと分からないじゃん
[1:40:35] セリカ 青緑波紋疾走: だから、Bのメソッドが使われると思い込んで使用することで
バグが出来ちゃうんだな
[1:41:49] ＠mugen しぃ（41）: でもさぁ、継承クラスとかスーパークラスのメソッドコールする時って
base.hoge()とかクラス名記述するんじゃないの？
[1:42:11] セリカ 青緑波紋疾走: 多重継承していなければ一意に特定できるからね
[1:42:24] ＠mugen しぃ（41）: 多重継承してたらbase.とか使えないの？
[1:42:31] セリカ 青緑波紋疾走: baseだけじゃいけない
[1:42:44] セリカ 青緑波紋疾走: それじゃどれかわからないから　プログラマの責務でどれを呼ぶか書かないとダメ
[1:43:43] セリカ 青緑波紋疾走: 実際　C++やっていると　このメソッドはAクラス、Bクラスの2クラスから継承されています。どちらを呼び出しますか？

というダイアログがコンパイル時にままでるよ
[1:43:58] ＠mugen しぃ（41）: 継承まだやった事ないけど、例えばtest1　test2の2つのクラス継承してて
両方にmeth（）ってのがあって、test2のmeth()を使いたい場合ってtest2.methとかしてコールするんじゃないの？
[1:44:28] セリカ 青緑波紋疾走: 動的束縛と静的束縛　というのがあるんですよ
[1:44:58] セリカ 青緑波紋疾走: 動的束縛　=　オブジェクト実体により呼ばれるものが決まる
静的束縛　=　オブジェクトの型により呼ばれるものが決まる
[1:45:15] セリカ 青緑波紋疾走: JavaやC#は動的束縛でC++は静的束縛
[1:47:09] セリカ 青緑波紋疾走: とあるメソッドをオーバーライドした子クラスが合って
その子クラスのオブジェクトを親クラスに代入してメソッドを呼び出した場合

動的束縛　＝　子クラス側のオーバライドされたメソッドが呼び出される。
　　　　　　　　　　実体を代入している型が親クラス型でも実体に依存する

静的束縛　＝　親クラス側のメソッドが呼び出される。
 　　　　　　　　　　実体を代入している型に依存するので中身が子クラスでも
 　　　　　　　　　　オーバーライドされた処理は呼び出されない
[1:47:57] セリカ 青緑波紋疾走: 枝が言っているのは　静的束縛　のことだね
[1:48:13] ＠mugen しぃ（41）: なるほど
[1:48:20] セリカ 青緑波紋疾走: でも、オブジェクトの多態性を有効に使うためには動的束縛が必要なんですよ
[1:48:37] セリカ 青緑波紋疾走: じゃないとさ、常にどのクラスのを呼び出すかって静的にコードに書き込むことになるでしょ
[1:49:03] セリカ 青緑波紋疾走: それじゃ、継承してオーバーライドして機能を追加してもさ
呼び出しているメインロジック側も修正が必要になるじゃない
[1:49:10] セリカ 青緑波紋疾走: 継承先のメソッドを呼ぶようにしないといけないからさ
[1:49:48] セリカ 青緑波紋疾走: だから、C++でもvirtualという宣言があって
メソッド定義時にvirtual宣言を付けると動的束縛になるのさ
[1:50:06] ＠mugen しぃ（41）: これってあらゆるメソッドをコールする時の概念だよな？
それとも、継承元のメソッドをコールする時だけの概念？
[1:50:19] セリカ 青緑波紋疾走: あらゆるメソッドをコールするときの概念
[1:50:31] ＠mugen しぃ（41）: なるほど
[1:50:51] ＠mugen しぃ（41）: virtualはC#のもある事だけは知ってる
[1:50:59] ＠mugen しぃ（41）: C#にも
[1:51:15] セリカ 青緑波紋疾走: この辺はinterfaceとも密接に絡むところ
[1:52:16] ＠mugen しぃ（41）: interfaceも実体がないスケルトンクラスって事で今までやった事ないから難そうなんだよな
明後日くらいからやる予定だが
[1:52:16] セリカ 青緑波紋疾走: interfaceでどういうメソッドが存在するクラスか？を定義しておけば
後は、interface型変数に、interfaceを実装したクラスの実体を代入することで
[1:52:35] セリカ 青緑波紋疾走: どんなクラスでもinterface型変数からアクセスができるんです
[1:52:56] セリカ 青緑波紋疾走: つまり、仕様と実装を切り離すことができる
[1:53:13] セリカ 青緑波紋疾走: interfaceにてどういう入力が入ったらどういう出力を返す　っていうのを定義する
[1:53:36] セリカ 青緑波紋疾走: その入力に対する出力をどう返すか？の実装は
interfaceクラスを実装した実オブジェクト側に実装する
[1:54:03] セリカ 青緑波紋疾走: でも、それら実体クラスはすべてinterface型変数に代入されるから
仕様と実装が切り離されるんですよ
[1:54:57] ＠mugen しぃ（41）: 理論は大体は分かる
あとは実際にやってみるって事と、実際のゲームではどういう所に使うかが分からんと思う
[1:55:09] セリカ 青緑波紋疾走: ゲームで説明するとマリオカートが分かりやすいかな
[1:55:15] ＠mugen しぃ（41）: interfaceは多重継承できるんだよな
[1:55:17] ＠mugen しぃ（41）: 確か
[1:55:21] ＠mugen しぃ（41）: クラスは1つのみだが
[1:55:49] セリカ 青緑波紋疾走: 加速するというインタフェースを用意したとするじゃん
このインタフェースはAボタンを押している間にマイフレーム呼び出すとするよね
[1:56:23] セリカ 青緑波紋疾走: つまり、マリオカートのメインロジック側は　Aボタンが押されたら　インタフェース加速　をマイフレーﾑ呼び出す　という部分は決めておく
[1:56:40] ＠mugen しぃ（41）: うん
[1:57:37] セリカ 青緑波紋疾走: で、このインタフェース加速　を継承した
・マリオの車加速　implments インタフェース加速
・ヨッシーの車加速 implments インタフェース加速
・クッパの車加速　implements インタフェース加速

という3つの実際のキャラクター毎のクラスを作る
[1:58:19] ＠mugen しぃ（41）: うん
[1:59:12] セリカ 青緑波紋疾走: マリオの車加速クラスでインタフェース加速
の実装は、呼び出される毎に速度を10加算するけど
最大で150までという処理にする

ヨッシーの車加速クラスでインタフェース加速
の実装は、呼び出される毎に速度を20加速するけど
最大で100までという処理にする

クッパの車加速クラスでインタフェース加速
の実装は、呼び出される毎に速度を7加速するけど
最大で200までという処理にする
[2:00:11] セリカ 青緑波紋疾走: これら3つのクラスは全て「インタフェース加速」を実装しているから
選ばれたキャラクターにより　作成する実態は
・マリオの車加速クラス
・ヨッシーの車加速クラス
・クッパの車加速クラス
と異なるけど、すべて「インタフェース加速」型変数に代入することができる
[2:00:41] セリカ 青緑波紋疾走: つまり、選ばれたキャラによりどのクラスを実態にするかさえ決めておけば
mainロジック側のAボタンを押している間にインタフェース加速をマイフレーム呼び出す
という部分は共通になるんだよ
[2:01:00] ＠mugen しぃ（41）: うん
[2:01:13] セリカ 青緑波紋疾走: 後は　マリオならマイフレーム10ずつ早くなるけどMAXで150
ヨッシーならマイフレーム20ずつ早くなるけどMAX100
クッパならマイフレーム7ずつ早くなるけどMAX200
[2:01:48] セリカ 青緑波紋疾走: という風に仕様（Aを押している間、一定ずつ加速して最大まで早くなる）という仕様と
マリオ、ヨッシー、クッパそれぞれの実装が
[2:01:57] セリカ 青緑波紋疾走: 完全に分担されているということですよ
[2:02:29] セリカ 青緑波紋疾走: 同じことは　→ボタンや←ボタンを押したときのハンドルが切れる角度にも言えるよね
[2:03:05] ＠mugen しぃ（41）: それぞれの異なる数値、加速度とかMAXの値は実装側で定数として与えるんだよな？
[2:03:28] セリカ 青緑波紋疾走: それを定数としてもいいし
調整しやすいようにiniファイルやxmlファイルから読み込んでもいい
[2:03:50] セリカ 青緑波紋疾走: ただ、実装側でどうするかが仕様と錐は慣れているから
[2:03:56] セリカ 青緑波紋疾走: 好きに作ってよくなるのさ
[2:04:01] ＠mugen しぃ（41）: なるほどな
[2:04:19] セリカ 青緑波紋疾走: インタフェースが求めるものが返せれば
その中でどうするかはどうでもよくなる
[2:04:23] セリカ 青緑波紋疾走: これが疎結合という考え方
[2:04:39] ＠mugen しぃ（41）: ほーん
[2:04:50] セリカ 青緑波紋疾走: これの素晴らしいことはね
[2:04:54] セリカ 青緑波紋疾走: バグフィックスがしやすいってことなのさ
[2:05:18] セリカ 青緑波紋疾走: クッパがバグってたとして　クッパ直すでしょ
[2:05:26] セリカ 青緑波紋疾走: でも、マリオとヨッシには絶対に影響でないでしょ
[2:05:33] ＠mugen しぃ（41）: うん
[2:05:37] セリカ 青緑波紋疾走: これが大事なんだよ
[2:05:44] セリカ 青緑波紋疾走: 疎結合にすることで副作用が少なくなる
[2:06:53] ＠mugen しぃ（41）: 大体分かった
[2:06:58] セリカ 青緑波紋疾走: RPGもさキャラクターと綿密に結合させるんじゃなくて
[2:07:36] セリカ 青緑波紋疾走: こんな感じで、キャラクターというインタフェースを作った後に
各キャラクターをそのインタフェースを実装したクラスとして別途作ると
[2:07:55] セリカ 青緑波紋疾走: キャラクター固有の技能の部分でバグって　そこを直しても
他のキャラクターに影響がないことが確実になるから
[2:08:00] セリカ 青緑波紋疾走: 管理がしやすいとか　そういう感じかな
[2:09:23] セリカ 青緑波紋疾走: まぁ、具象なオブジェクトからインタフェースを切り出す作業を
抽象化というんだけど
オブジェクト指向設計の難しいところなんだな！！
この抽象化という作業が
[2:10:19] ＠mugen しぃ（41）: HPとかMPとかSTRとかVITとかのパラメータって味方のキャラ全員共通じゃん
で、HPとかのそれらってキャラ固定じゃん
主人公はHP200、ヒロインはHP120toka
こういうパラメータって
[2:10:47] ＠mugen しぃ（41）: コンテナクラス作って、それ継承してそこを読み書きしようと思ってるんだが
[2:11:04] ＠mugen しぃ（41）: インターフェイスは「処理」だから違うよな
[2:11:17] セリカ 青緑波紋疾走: 良いところに気が付きましたね　素晴らしい
[2:11:27] セリカ 青緑波紋疾走: そのために存在するのが　抽象クラス　です
[2:12:00] ＠mugen しぃ（41）: 例えば、「たたかう」を押したら全員通常攻撃するから、インターフェイスはそういう所で使うって事か？
[2:12:34] セリカ 青緑波紋疾走: その通り、でHP、STRなど共通パラメータは
その抽象クラスを作ってそこに持たせる
[2:12:51] ＠mugen しぃ（41）: abstract（抽象クラス）って実体持てないだろ
[2:13:00] ＠mugen しぃ（41）: 定義だけで
[2:13:20] セリカ 青緑波紋疾走: 抽象クラスはフィールドは持てるよ
[2:13:30] ＠mugen しぃ（41）: 宣言だけだよな？
[2:13:51] ＠mugen しぃ（41）: 実数やストリングス入れられないよね？
[2:14:00] セリカ 青緑波紋疾走: フィールドを宣言できるから
どんなフィールドがあるかは抽象クラスで決められる
後、抽象クラスはデフォルト実装もかける
[2:14:18] ＠mugen しぃ（41）: でもさ
[2:14:33] セリカ 青緑波紋疾走: インタフェースにもフィールドはかけるけど　処理はかけない
[2:14:40] ＠mugen しぃ（41）: そのそのフィールドにHPとかの実数入れるのはキャラクタークラスって事だよな？
[2:14:52] ＠mugen しぃ（41）: でもその
[2:15:10] セリカ 青緑波紋疾走: 実数を入れるためのインタフェースがあるとして
HPならマイナスにならない　最大HPを超えない　位じゃない大事なのは
[2:15:28] セリカ 青緑波紋疾走: それを全ての個別キャラクタークラスに入れるのだるいっしょ
だったら、抽象クラスでデフォルト実装しちゃえばいい
[2:16:18] セリカ 青緑波紋疾走: この説明は良くないね
[2:16:29] セリカ 青緑波紋疾走: HPの実数とかはキャラクタークラス側で持つ値だろうから
[2:16:53] セリカ 青緑波紋疾走: どちらかというと　HP減らす処理　とかかな
デフォルト実装で書いておくと楽なのは
[2:17:23] セリカ 青緑波紋疾走: でも、setterはデフォルト実装してもいいか
そのsetterに渡す値をどこからとるかを
キャラクター個別のクラスに書けばいいし
[2:17:51] セリカ 青緑波紋疾走: セーブデータからとるもよし、定数をsetterに渡すもよし
ファイルから読み取るもよし
[2:18:18] セリカ 青緑波紋疾走: でも、セットしたいHPとしては
マイナスはダメ　最大HPを超えない　というルールになるから
それは抽象メソッドにデフォルト実装できるかな
[2:18:32] ＠mugen しぃ（41）: abstractってint test = 20;とかできないよな？
[2:18:37] セリカ 青緑波紋疾走: できるよ
[2:18:48] ＠mugen しぃ（41）: マジに？
[2:18:55] ＠mugen しぃ（41）: でもそうすると実体持っちゃうじゃない？
[2:19:22] セリカ 青緑波紋疾走: 抽象クラスのフィールドは実体を持たない　っていう訳じゃないからね
[2:19:41] セリカ 青緑波紋疾走: 抽象的な処理や値を管理するクラス　という意味だからね
[2:19:59] ＠mugen しぃ（41）: そうなの？俺は持たないと思ってたっていうか、確かどっかに抽象クラスは実体持たないとか書いてた記憶がある
[2:20:17] セリカ 青緑波紋疾走: ああー　それは　newできない　ということ
[2:20:55] ＠mugen しぃ（41）: ほーん
[2:21:52] ＠mugen しぃ（41）: っていうかさ
[2:21:52] セリカ 青緑波紋疾走: abstract class test {

}

というクラスを
  Test testObj = new Test();
とするとエラーが出る
[2:22:00] セリカ 青緑波紋疾走: つまり、実体を持つことはできない
[2:22:14] ＠mugen しぃ（41）: newてインスタンス取るんだっけ？
[2:22:33] セリカ 青緑波紋疾走: new演算子はインスタンス（実体）を作る命令だね
[2:22:39] ＠mugen しぃ（41）: なるほど
[2:22:52] ＠mugen しぃ（41）: フィールドは値持てるのか
[2:23:07] セリカ 青緑波紋疾走: もてる、ただフィールドを参照するためにはインスタンスが必要でしょ？
[2:23:20] ＠mugen しぃ（41）: うん
[2:23:34] ＠mugen しぃ（41）: でも実数入れたら何か抽象の意味あんまない気がするけど
[2:23:37] セリカ 青緑波紋疾走: で、abstractクラスはそのインスタンス（実体）が作れないってこと
[2:23:48] ＠mugen しぃ（41）: 理解した
[2:23:56] セリカ 青緑波紋疾走: 使い方次第だねー　共通で使う定数と甘楽
[2:24:16] セリカ 青緑波紋疾走: 共通で使う定数とかなら抽象クラスで
final宣言して作っておくとかしたいしものもあるだろうし
[2:24:42] ＠mugen しぃ（41）: たださぁ、unityって仲間や主人公のクラスって画面切り替わるたびにdestroyされる
[2:25:20] ＠mugen しぃ（41）: だから画面変わる度に、主人公とかのパラメータ全部どっかに避難させて、シーン変わったらまた主人公クラスで読み込まないといけない
[2:25:52] セリカ 青緑波紋疾走: untiyの作りが分からないけど
パラメータをどっかに退避させるんだったら
主人公クラスの実体を退避させればいいんじゃないの？
[2:26:21] セリカ 青緑波紋疾走: 変数が退避できるのなら主人公クラスの実体も退避できるでしょ
[2:27:17] ＠mugen しぃ（41）: うん、今それでやってる
DontDestroyOnLoadってすると消えないクラス作れるから、そのクラスに
味方分のint HPとかint MPとかフィールド作って、シーン変わる前に現パラメータを書き込み、シーン変更後に再度自動で作られる主人公クラスで読み込み、って感じ
[2:28:09] セリカ 青緑波紋疾走: 別にパラメータとかを個別に読み込んだりしないで
その主人公クラスそのものをいったん退避すればいいんじゃない？
[2:28:30] ＠mugen しぃ（41）: でもそれだと仲間全員のクラス退避させないといけないから管理が大変だろ
画面跨いでずっと残るって事は逆に削除し忘れたりする
[2:28:53] ＠mugen しぃ（41）: それだと主人公クラスとか仲間全員のクラスにDontDestroyOnLoadしないといけない
[2:29:03] セリカ 青緑波紋疾走: それこそ共通処理に書いちゃえばいいでしょ
その画面が切り替わるときのフックイベントみたいなのないの？
[2:29:18] セリカ 青緑波紋疾走: 画面が切り替わるフックイベントと
切り替わって表示されるフックイベントに
[2:29:36] セリカ 青緑波紋疾走: 共通処理として実装しちゃえばいいんじゃない？
主人公クラスの退避処理
[2:30:08] セリカ 青緑波紋疾走: 毎回　手でやったらミス出ちゃうだろうから
フレームワーク的な部分でやっちゃえば
[2:30:11] セリカ 青緑波紋疾走: と思いました
[2:31:24] セリカ 青緑波紋疾走: 実装はuntiyの仕様わからないので
できないことを言っている可能性もあるけど！！
[2:33:36] ＠mugen しぃ（41）: コンテナクラスに全員分のHPやMP書いてるけど、どうよ？
//主人公パラメータ
int chr1_HP;
int chr1_MP;
int chr1_SP;
・
・
//ヒロインパラメータ
int chr2_HP;
int chr2_MP;
int chr2_SP;
・
・

これを画面変わっても消えないクラス一つ作って、そこに定義して
画面変わる度に消去、起動する主人公クラスが読み書きしてる
[2:34:16] ＠mugen しぃ（41）: 画面変わる時主人公クラスで
コンテナクラス.HP = this.HP
コンテナクラス.MP = this.MP


とか
[2:35:12] セリカ 青緑波紋疾走: untiyの仕様が分からないので何ともですが
プリミティブ型以外は全て消えちゃうってことかな？

そうであれば、プリミティブ型に一度退避して戻す必要があるのは納得
[2:35:47] セリカ 青緑波紋疾走: そうじゃないのなら、主人公インスタンスそのものを退避すれば
良いのではないかと思います
[2:36:13] ＠mugen しぃ（41）: というか、何もしなければ画面チェンジのたびに変わる度に全て消える
だからunityでは使わないリソースずっと残ってメモリ食う事がない
[2:36:58] セリカ 青緑波紋疾走: 何かすれば残るというのであれば
主人公インスタンスを消さないってしとけばいいんじゃないかな？
[2:37:18] セリカ 青緑波紋疾走: ゲーム起動中に主人公インスタンスとか消す必要はないように感じます
[2:37:48] ＠mugen しぃ（41）: でもそうすると、仲間のインスタンスも全部残さなきゃいけないじゃん？
[2:38:02] セリカ 青緑波紋疾走: 仲間のインスタンスも残ってていいんじゃないかな？
[2:38:43] セリカ 青緑波紋疾走: インスタンスが残っていると強制的に画面に表示されちゃうとか
あるのなら困るだろうけど
インスタンスが残っていても別に困らないのではないかと思う
[2:39:26] ＠mugen しぃ（41）: それでもいいのかもしれないけど、それをするにはDontDestroyOnLoadを
クラス内に書かないといけないんだが、なんかあんまDontDestroyOnLoadクラスを
多くつくるってのは聞いたことないから消して、DontDestroyOnLoadクラスは1〜2個にしようって感じでやってる
[2:40:11] セリカ 青緑波紋疾走: 聞いた話だけだと
キャラクターを管理しているクラスはDontDestroyOnLoadで良い気がします
[2:40:41] ＠mugen しぃ（41）: DontDestroyOnLoadクラス作りまくる弊害って多分、消し忘れたらメモリ食いまくるって事くらいだと思うけど
[2:42:08] セリカ 青緑波紋疾走: 消す必要があるクラスを消さない　これはダメだけど
消す必要がないクラスだから消さない　これは設計として妥当なんじゃないかな
と思ったんですよ

で、RPGならゲーム進行中に仲間キャラクターの情報とかは
消す必要がないのではないかと思います

ただし、消さないと画面から表示が消せないとか
一時的に離脱させたいけど消さないとPTから抜けないとか
制約があるなら別
[2:42:41] ＠mugen しぃ（41）: まー俺もそう思うよｗ
[2:43:53] ＠mugen しぃ（41）: ただまぁ、確かにDontDestroyOnLoadしない方がパーティに加える、外すは融通効くのかなって感じはするな
[2:44:28] セリカ 青緑波紋疾走: その辺はuntiy読んでみないと
俺は判断できないです
[2:45:05] ＠mugen しぃ（41）: まぁまず作るのは青鬼とかIb程度になると思うからどっちでもさして問題ないけど
[2:45:53] セリカ 青緑波紋疾走: 俺も来月から時間出来るから
引っ越しとか片付いたらUntiyちょっと見てみるよ
[2:46:10] ＠mugen しぃ（41）: 今いるサークルに日本一ソフトウェアの人がいるんだけど、日本一ソフトウェアってすごいの？
[2:46:20] ＠mugen しぃ（41）: メタルギアとかだっけ？最近ゲームやらんから知らんけど
[2:46:47] セリカ 青緑波紋疾走: 日本一はメジャーなゲーム会社だね
一番のヒット作はディスガイアシリーズじゃない？

俺も、最近のゲームは疎いけど
[2:47:00] ＠mugen しぃ（41）: あーディスガイアね
[2:47:35] セリカ 青緑波紋疾走: 一昨年だかのクソゲーオブザイヤーの大賞も日本一だったかな
[2:47:51] ＠mugen しぃ（41）: 何のゲームで？
[2:48:03] ＠mugen しぃ（41）: あんまいい売れ行きじゃないのかな
[2:48:32] セリカ 青緑波紋疾走: 2010年のクソゲーオブザイヤーだった　ラストリベリオン
[2:48:44] セリカ 青緑波紋疾走: http://koty.sakura.ne.jp/index.php?2010%C7%AF%20%C2%E7%BE%DE
[2:50:06] セリカ 青緑波紋疾走: 東証一部に上場している会社だから
会社としては大きくて安定している会社ですよ
[2:50:17] セリカ 青緑波紋疾走: 東証一部上場するために満たさないといけない基準は結構大変だからね
[2:50:41] ＠mugen しぃ（41）: スクエニと同じくらいか
[2:50:49] セリカ 青緑波紋疾走: あ　ごめん　一部じゃなかった
[2:50:54] セリカ 青緑波紋疾走: 東証ジャスダックだった
[2:51:02] セリカ 青緑波紋疾走: 新興市場だな
[2:51:35] セリカ 青緑波紋疾走: つまり、市場評価的にはまだまだ新興企業とみなされているってことですね
[2:51:52] セリカ 青緑波紋疾走: まぁ、東証に上場すると毎月東証に払う維持費が高いから
[2:52:10] セリカ 青緑波紋疾走: 意図的にジャスダックにしている可能性もあるけどね
マクドナルドとかもその理由でジャスダックにしか上場してないし
[2:52:38] ＠mugen しぃ（41）: まだ2年目らしい
[2:53:17] セリカ 青緑波紋疾走: 年数で力量は単純に測れないけど　まだまだなんじゃないかな？
と思いました
[2:53:46] セリカ 青緑波紋疾走: まぁ、2年目でどの程度戦力になるかは
会社の教育方針次第ですね

