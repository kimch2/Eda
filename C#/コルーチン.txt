
マルチスレッド
------------------
　・メインスレッドとは別スレッドを立てて処理を行う。
　・メインスレッドと独立しているため、重い処理を行ってスレッド落ちしてもメインスレッドに影響は出ない。
　・コンテキストスイッチ：CPUの状態を切り替える。そのためマルチスレッドは案外重い。
　・Unityの機能(ゲトコンとか)は使えない。
　・シングルCPUの場合：コンテキストを切り替える事で擬似的にメインスレッドと並列処理してるように見せる
　　マルチCPUの場合：メインスレッドとサブスレッドが完全並列で動作する

グリーンスレッド（強調形スレッド、C#のコルーチンはグリーンスレッド）
------------------
　・「メインスレッド上で」非同期に動くので、重い処理をグリーンスレッドでやるとメインスレッドに影響を及ぼす。
　　重い処理はメインスレッドに影響を与えないためにも、別スレッドを立ててマルチスレッドでやる方がいい。
　・タスクスイッチング：メインスレッド上で動いているタスクを細かく切り替える。
　・メインスレッドの処理時間を細かく切って、各タスクに分配することで、複数のタスクが同時並行的に
　　動いているかのように動作すること。
　・グリーンスレッドでは、処理の完了が保証されるのはアトミックな処理（CPU命令単位）に限る。
　・Unityの機能(ゲトコンとか)も使える。

アトミックな処理（CPU命令単位）とは
------------------
それ以上分割できない単位の処理。
int x = 10;　など変数への代入処理がアトミックな処理。
ただし、
int x = 10;　①
int a = 10;　②
int z = x+a; ③
は、①と②と③はそれぞれアトミックな処理だが、①と②と③のどこかでタスクスイッチングとして
別のタスクが割り込む可能性がある。
グリーンスレッドであるコルーチンはアトミックな処理による処理の完了が保証されるが
①と②と③全てをコルーチン内でやるとすると、①だけ、②だけ、③だけの代入は保証されるが
①②③全ての代入の完了を保証はしないため、①②だけコルーチン内で代入したが③の代入を行う前に
別の処理による参照等が行われるタスクスイッチングが発生する可能性があり、その場合は
想定した動作にならないバグが発生する。


非同期で行いたい処理を、IEnumerator型の戻り値を返すメソッドとして記述することで、コルーチンとして実行させることができる。

コルーチンとして作成したメソッドを引数として、StartCoroutine()を実行するとコルーチンが開始される。
StartCoroutine()はノンブロッキングなAPIなので、コルーチンを実行した直後に処理が戻り、以降のコードを実行する。

但し、yield return StartCoroutine()という形で実行した場合は、コルーチンの実行が終了するまで処理がブロックされる。
その為、yield returnを用いて実行したコルーチンは同期処理になる。

コルーチンは非同期処理を行うことができるが、スレッドを作成して非同期処理を行う場合とは異なり、メインスレッド上で動作する。

スレッドを作成した場合は、異なるスレッドにて処理を実行するため、作成したスレッドで重たい処理を行ったとしても
（CPUを食いつぶしていなければ）、メインスレッドに影響は出ない。

それに対して、コルーチンはメインスレッド上で協調型スレッド（グリーンスレッド）として非同期処理を行うため、
コルーチンが重たい処理を行うと（CPUを食いつぶしていなくても）、メインスレッドに影響が出る。
なので、コルーチンでは適宜yield returnにて処理を中断させることで、一度に行う処理を軽くする必要がある。
この考え方はリアルタイムOSでタスク時間を超えないように処理を細かくするのに近いと思った。

Unityでは、yield　returnを行うことで、以降の処理は次のフレームに回される。
その為、MonoBehaviour.Start()でコルーチンを実行すれば、開始から終了まで一方通行で実行されるMonoBehaviour.Update()のような使い方も可能である。

但し、MonoBehaviour.Start()ではスクリプトに必要な初期処理を行い、
以降そのスクリプトが有効な間はMonoBehaviour.Update()に定義された動作を実行するというのが
Unityで作成するスクリプトの基本的な思想なので、適当にStartCoroutine()を使ってコルーチンと
MonoBehavior.Update()で動作の実装箇所が複数に別れてしまうと後々の可読性を低下すると思う。

そう考えると、StartCoroutine()の使い所は、ボタンクリックなどイベント発生時が望ましいのではないかと思う。

多分、MonoBehaviour.Update()にバリバリ処理が実装されているにも関わらず、
同じスクリプトでStartCoroutine()を実行しているなら、それは処理分割を検討する必要があるのだと思う。

仮に、MonoBehaviour.Update()とStartCoroutine()でお互いに副作用を与えていたとしたら、
その結果発生したバグを追跡するのは非常に困難であると考えられる。


------------------
だから、Update()にバリバリ処理が書かれているScriptでStartCoroutine()を何個も実行する設計って

それ、本当は処理が分割されるべきじゃないの？
そのスクリプト、神のオブジェクトになってない？
と私は違和感を感じます
------------------
