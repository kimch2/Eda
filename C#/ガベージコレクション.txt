
-----------
前提
-----------
・GCは.NETのCLRが管理している
・ネイティブヒープとマネージヒープがあり、GCが動くのはマネージヒープ。
　※マネージヒープ→GCが管理に使うメモリ領域　ネイティブヒープ→OSが使うメモリ領域
・通常はヒープのごく一部だけを占有する有効期間が短いオブジェクトを解放する場合に発生する
・スタックにあるデータは変数が使われなくなると（スコープの範囲外に出ると）すぐに自動的に解放される。
・列挙型のnewを使うとガベージが発生するためGC対象となる

------------------------------
GCが発生する条件は3つある
------------------------------
・物理メモリが少なくなった場合
・ヒープで割り当てられたオブジェクトによって使用されているメモリが、許容されるしきい値を超える場合（常に調整されている）
・GC.Collectメソッドにより明示的に呼び出された場合
　ただしほとんどの場合GCは継続実行されるため、このメソッドを呼び出す必要はない（テスト目的）

-----------
ポイント
-----------
・.NET Framework でメモリー管理は自動化されたが管理外のリソース（ファイルIO等）もある
・管理外のリソースは明示的に破棄(Dispose)が必要
・例外が発生した場合でも正しくリソース破棄ができるように、try-catch-finally や using を使う事
・マネージヒープが使われる程GCの稼働が増える。なので12byteの配列が必要な時に20byteの配列を組むなどすると
　GCの稼働率が上がり、余計なタスクが生じてしまうので避ける。

-----------------------
ジェネレーション
-----------------------
・ヒープ領域は有効期間に応じて3つのジェネレーションという単位に区切られている。
・詳細は：https://msdn.microsoft.com/ja-jp/library/ee787088.aspx


ファイルや周辺機器などのリソース(OSが管理している資源)を使用する場合、
まずリソースを使用する権利を取得しリソースに対する操作(ファイルの読み書きなど)
を行った後リソース使用権を破棄する必要がある

メモリは .NET Frameworkの(正確にはCLRの)ガーベジコレクション機能が自動的に管理していて、
プログラマが明示的に破棄してやる必要はないのですが、 ファイルなどはガーベジコレクションの
管理対象外で、 明示的な破棄が必要

リソースの破棄を怠ると操作が正しく完了しなかったり、他のプログラムからそのリソースを使用できなくなったりする
例えば、ファイルにロックが掛かったままになってファイルの読み書きがしばらくできなくなる



