
●エイリアス
　→別名。

●モーダルダイアログ
　→ダイアログを開いたら、そのダイアログを閉じるまで他の操作を受け付けないダイアログ。
　　不便なため、最近ではなるべくモードレスダイアログにするよう配慮が進められている。

●メンバ関数メソッド
　→同じ意味。メソッドはクラス内に定義された関数全般で、それは二種類に大別される。
　　インスタンスに依存するインスタンスメソッドと、staticなクラスメソッドである。
	　　メンバ関数（メソッド）
	　　　┗クラス関数（クラスメソッド）
	　　　┗インスタンス関数（インスタンスメソッド）

●シンタックス
　→プログラミング言語などの人工言語で定められている構文規則。文法とも訳される。

●多重ディスパッチ
　→Dispatch(配送の意)。
　　仮想メソッドにおいて型を見て起動するメソッドを切り替える事。
　　型情報によって配送先メソッドを決める。
　　参考：http://ufcpp.net/study/csharp/sp4_multipledispatch.html

●シンタックスシュガー（糖衣構文）
　→特定の記述を短縮した書き方。可読性が向上し、バグを減らせる可能性がある。
　　null許容型（int?とか）やラムダ式は糖衣構文の一種。

●ラップ
　→あるクラスや関数、データ型などが提供する機能やデータを含み、別の形で提供すること。
　そのクラスや関数などのことを「ラッパー」という。

●プロシージャル
　→直訳で「手続き的な」の意。特定の処理を自動化(自動制御)したり、自律化させること。

●WPF（Windows Presentation Foundation）
　→.NET Frameworkに含まれるプレゼンテーション層技術（GUI開発ライブラリ）

●オブジェクト指向
　→オブジェクト指向の3大要素（カプセル化、継承、ポリモフィズム）

●デプロイ（デプロイメント）
　→開発したプログラムを実際の運用環境(サーバ上)に展開すること。

●テンプレートメソッド
　→複数のオブジェクトに共通した処理を基底クラスに書き、
　　固有の処理をサブクラスに書くデザインパターンのこと。

●ストラテジーパターン
　→処理をオブジェクト化し、切り替える事により既存部分の処理に
　　手を加えたり変更したりデバッグの対象から外す処理にすること。

●デザインパターン
　→よくあるアーキテクチャ（≠実装、＝仕様）に対して
　　名前を付けて知識の共有をしようというコンセプト
　　最もよく使われるデザインパターンは「GoFの23のパターン」
　　逆に、やってはいけないデザインパターンを「アンチパターン」という
　　※「Gang of Four（ギャング・オブ・フォー）」略して「GoF（ゴフ）」
　　※参考：http://www.nulab.co.jp/designPatterns/designPatterns1/designPatterns1-2.html

●リファクタリング
　→動的にアーキテクチャを変更したいという要求や、後々
　　アーキテクチャを追加したりメンテナンスしやすいよう
　　既存コードのクオリティを上げること。
　　ストラテジーパターンは動的にコードを変更する(切り替える)ための
　　ものなので、ストラテジーパターンとリファクタリングは異なる

●外部変数のキャプチャ
　→匿名メソッド/ラムダ式で外部の変数が使用される場合、その変数は
    メソッドのローカル変数ではなく、コンパイラが生成するクラスのフィールドになる
　　結果的に外部変数の寿命が、匿名メソッドが参照するデリゲートがGCできる状態になるまで
　　延命される事になる　　

●インデクサ
　→stringなどの配列以外のクラスで、配列を扱うように見せかけられるプロパティ
　　インデクサとは「引数付きのプロパティ」である
　　これがインデクサの実体（右はstringのインデクサ）→public char this[int index] { get; }

●データ構造
　→データを保持する形式や方法
　　コンピュータに近い説明だと「メモリ上での表現方法」とか、
　　「データをメモリ上にどのように展開/保持するか」ということ
　　線形データ構造、グラフデータ構造、木構造などがある

●スレッドセーフ
　→マルチスレッドプログラミングにおける概念。
　　あるコードがスレッドセーフであるという場合そのコードを複数のスレッドが
　　同時並行的に実行しても問題が発生しないことを意味する。
　　スレッドセーフは実際の処理の流れとプログラムのソースコードの関連性を強化し、
　　予期しない動作を最小にすることを指向した特性である。

●アンマネージコード
　→CLRの外部で動作するコードで、中間言語(IL)はCLR上で動く
　　※CLRの制御下で動作するコードをマネージコード

●ascending、descending
　→昇順と降順の意味

●シグネチャ
　→「メソッド名」、「引数の数」、「引数の型」をまとめてシグネチャと呼ぶ
　　上記3つが同じメソッドを「シグネチャが同じメソッド」という
　　アクセシビリティは含まない
　　Javaは同じシグネチャのメソッドを同一クラス内で宣言できない
　　プロパティのシグネチャはメソッドのシグネチャに似ている。
　　フィールドのシグネチャは単に型です。

●コンテキスト
　→文脈

●メンバ
　→メソッドのこと（メンバ関数とか言う）

●リテラル
　→「10」とか「1.12」とかの実数のこと
	bool   b = true;    // 論理値リテラル
	int    n = 26983;   // 整数リテラル
	double x = 10.362;  // 実数リテラル
	char   c = 'a';     // 文字リテラル
	string s = "文字列"; // 文字列リテラル

●コレクション（コレクションクラス）
　→ListやArrayListや配列などのクラスのこと

●カプセル化
　→オブジェクト内の細かい仕様や構造を外部から隠蔽すること。
　　外部からは公開された手続きを利用することでしかデータを操作できないように
　　することで、個々のオブジェクトの独立性が高まる。
　　カプセル化を進めることによりオブジェクト内部の仕様変更が外部に影響しなくなり、
　　ソフトウェアの保守性や開発効率が高まり、プログラムの部分的な再利用が容易になる。

●ガベージコレクション
　→解放漏れなどで使うことのないヒープ領域が残ったり
　　逆に解放済み領域を再度解放してしまう事がある(二重解放)。
　　こういった事が起こらないよう、メモリ管理を自動化する方法がガベージコレクション。
　　また、断片化の隙間を詰めて最適化する事を「●コンパクション」という。
　　.NET Frameworkの上で動くC#などの言語はヒープを管理にこのガベージコレクションを使う。

●デストラクタ
　→インスタンスを解放する処理。コンストラクタの前に「~」を付ける。
　　また、ガベージコレクション(GCと略)で領域解放する場合もデストラクタが呼ばれるが
　　これは内部的にはデストラクタではなくファイナライザと呼ばれる。
　　（C#で書いたデストラクターは、コンパイルすると Finalize というメソッドに変換されるという事）
　　GC時に(Finalize メソッドなどの)終了処理を行うことを●ファイナライズと言う
　　インスタント解放をGCに任せず任意のタイミングでする場合、IDisposableを継承して
　　using(名前空間でない意味での)を使ってDisposeさせてやる必要がある

●マーシャリング
　→異なるコンピューターシステムやプログラミング言語の間で、データをやり取りできるようにするための処理。

●多態性(polymorphism: ポリモーフィズム)
　→オブジェクト志向三大要素（カプセル化 / 継承 / 多様性）のひとつ。
　　同じメソッド呼び出し(オブジェクト指向用語的には「メッセージ」という)に対して
　　異なるオブジェクトが異なる動作をすること。メソッドのオーバーロードも多態性の一種

●アップキャスト / ダウンキャスト
　→基底クラスの変数に派生クラスの変数を渡すこと。
　　逆に、派生クラスの変数に基底クラスの変数を渡すのはダウンキャスト。
　　アップキャストは安全だが、ダウンキャストは安全とは限らない。
　　参考：http://ufcpp.net/study/csharp/oo_polymorphism.html#downcast

●is演算子
　→「フィールド名 is 型名」で書かれる。戻り値はboolean型。
　　左辺のフィールドが右辺の型でキャスト可能ならtrue、そうでなければfalseを返す。
　　例）　if(b is Derived1)

●as演算子
　→キャストと同じだが、型変換できなければnullを返すという違いがある。
　　例）　d = b as Derived1;
　　　　　if(d != null) Debug.Log("キャストできた")

