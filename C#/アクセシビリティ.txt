
public (Public) : どのクラスからもアクセスできる。
private (Private) : そのメンバが宣言されているクラス内でアクセスできる。
protected：private + 継承等で派生したクラス内
internal：そのメンバと同じアセンブリファイル（EXEファイルやDLLファイル）内からのみアクセスできる。
protected internal：protected + internalのアクセス範囲。

----------------------
internal
----------------------
internal はちょっと難しい概念でコードと言うよりは　パッケージレベルでアクセスが制限されるというニュアンス
基本となる実行ファイルexeに対して拡張機能としてdllを提供したとするじゃない

この場合、exeはdllが無くても動くよね
基本的なアプリはexeでdllはあくまでもその機能を拡張するツールなわけだから

で、この場合にexe側のソースはprotectedやpublicで良いんだけどdll側のソースはinternalが良いのよ
なぜなら、
exe側の機能はdllが使える。これは当たり前だね
dll側の機能はexeは使えない。

もしdll側でpublicなクラスだったらexe側でusingに追加して呼び出せてしまう訳
そうしたら、以降はexeとdllを常に同時に配布する必要が出る

ソースをinteranlで記述することで同じアセンブリ内の任意のコードからアクセスできますが、別のアセンブリからはアクセスできません。

つまり、コード記述時点でexe側のアセンブリからdll側のアセンブリにはアクセス出来ない

というアクセス制限を適用することで
コードを書いている時に間違えてexe側からdll側の機能にアクセスするという過ちを防げる


プログラマが適切に管理すれば良いというものを「プログラマの責務」と表現するけど
この「プログラマの責務」を「言語の責務」に置き換えて負担を軽くする仕組みだね

ジェネリクス（総称化）とかと同じだよ
型を適切に合わせるべしというプログラマの責務を言語の責務に落とし込んだものがジェネリクス

Arrayを使うと　中に入っているオブジェクトが何なのかを管理するのはプログラマで
Arrayから取得したオブジェクトを適切にキャストして使う必要があるけど

ジェネリクスコレクションであるListなら型指定を<>の形で定義することで
Listに入っている型が安全であるかをコンパイル時点でチェックできるわけ

Internalもそう
異なるアセンブリ間で不適切なアクセスがされていないかをコンパイル時点でチェックできる




